<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Earth with Orbiting Satellite - Keplerian Orbits</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <div id="info">Earth with Orbiting Satellites - Keplerian Orbits</div>
    <div id="loading">Loading... <span id="progress">0%</span></div>
    <div id="controls">
        <div>
            <label for="perigee">Perigee (km):</label>
            <input type="number" id="perigee" value="500" min="200" max="5000">
        </div>
        <div>
            <label for="eccentricity">Eccentricity:</label>
            <input type="number" id="eccentricity" value="0.1" min="0" max="0.9" step="0.01">
        </div>
        <div>
            <label for="inclination">Inclination (°):</label>
            <input type="number" id="inclination" value="45" min="0" max="180">
        </div>
        <div>
            <label for="lonAscNode">RAAN (°):</label>
            <input type="number" id="lonAscNode" value="0" min="0" max="360">
        </div>
        <div>
            <label for="argPeriapsis">Arg. Periapsis (°):</label>
            <input type="number" id="argPeriapsis" value="0" min="0" max="360">
        </div>
        <div>
            <label for="speed">Speed Multiplier:</label>
            <input type="number" id="speed" value="1" min="0.1" max="10" step="0.1">
        </div>
        <button id="updateOrbit">Update Orbit</button>
    </div>
    
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';

        /**
         * Main application class for Earth-Satellite(s) visualization
         * @class EarthSatelliteApp
         */
        class EarthSatelliteApp {
            /**
            * Creates an instance of EarthSatelliteApp.
            * @constructor
            */
            constructor() {
                //** Scene setup **//
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                
                //** Loaders **//
                this.textureLoader = new THREE.TextureLoader();
                this.gltfLoader = new GLTFLoader();
                
                //** Main Objects **//
                this.earth = null;
                this.stars = null;
                this.satellites = []; // Array to store all satellite objects
                this.orbitPaths = []; // Array to store all orbit paths
                
                //** Scaling factor for visualization (Earth radius in scene units) **//
                this.earthRadiusSceneUnits = 4;
                //** Converting km to scene units **//
                this.earthRadius = 6371;

                this.scaleFactor = this.earthRadiusSceneUnits / this.earthRadius;
                //** Default satellite model path **//
                this.satelliteModelPath = './Assets/Messenger-Sat.glb';
                
                //** Loading indicator elements **//
                this.loadingEl = document.getElementById('loading');
                this.progressEl = document.getElementById('progress');
                
                this.init();
            }
            
            /**
            * Initialize the application
            * @method init
            */
            init() {
                this.setupRenderer();
                this.setupCamera();
                this.setupControls();
                this.setupLights();
                this.createEarth();
                this.createStars();
                this.setupUI();
                this.addEventListeners();
                
                //** Load satellites from JSON **//
                this.loadSatellitesFromJSON();
                
                //** Start animation loop **//
                this.animate();
            }
            
            /**
            * Setup the WebGL renderer
            * @method setupRenderer
            */
            setupRenderer() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.physicallyCorrectLights = true;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.5;
                document.body.appendChild(this.renderer.domElement);
            }
            
            /**
            * Setup the camera
            * @method setupCamera
            */
            setupCamera() {
                this.camera.position.z = 15;
            }
            
            /**
            * Setup the orbit controls
            * @method setupControls
            */
            setupControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.1; 
                this.controls.zoomSpeed = 0.4;     
                this.controls.rotateSpeed = 0.8;   
                this.controls.minDistance = 5;
                this.controls.maxDistance = 30;
            }
            
            /**
            * Setup scene lighting
            * @method setupLights
            */
            setupLights() {
                const ambientLight = new THREE.AmbientLight(0xffffff, 2);
                this.scene.add(ambientLight);
            }
            
            /**
            * Create the Earth object
            * @method createEarth
            */
            createEarth() {
                const earthGeometry = new THREE.SphereGeometry(this.earthRadiusSceneUnits, 64, 64);
                
                //** Load Earth textures **//
                const earthMap = this.textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/planets/earth_atmos_2048.jpg');
                const earthBumpMap = this.textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/planets/earth_normal_2048.jpg');
                const earthSpecMap = this.textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/planets/earth_specular_2048.jpg');
                const earthClouds = this.textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/planets/earth_clouds_1024.png');
                
                //** Earth material creation **//
                const earthMaterial = new THREE.MeshPhongMaterial({
                    map: earthMap,
                    bumpMap: earthBumpMap,
                    bumpScale: 0.1,
                    specularMap: earthSpecMap,
                    specular: new THREE.Color('white'),
                    shininess: 15
                });
                
                //** Create Earth mesh **//
                this.earth = new THREE.Mesh(earthGeometry, earthMaterial);
                this.earth.receiveShadow = true;
                this.scene.add(this.earth);
                
                //** Cloud layer **//
                const cloudsGeometry = new THREE.SphereGeometry(this.earthRadiusSceneUnits + 0.03, 64, 64);
                const cloudsMaterial = new THREE.MeshPhongMaterial({
                    map: earthClouds,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
                this.scene.add(this.clouds);
            }
            
            /**
            * Create the background stars
            * @method createStars
            */
            createStars() {
                const starsGeometry = new THREE.BufferGeometry();
                const starsMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.3,
                    transparent: true
                });
                
                const starsVertices = [];
                for (let i = 0; i < 15000; i++) {
                    const [x,y,z] = Array(3).fill().map(()=> THREE.MathUtils.randFloatSpread(2000));
                    starsVertices.push(x, y, z);
                }
                
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
                this.stars = new THREE.Points(starsGeometry, starsMaterial);
                this.scene.add(this.stars);
            }
            
            /**
            * Load satellites from JSON data
            * @method loadSatellitesFromJSON
            */
            loadSatellitesFromJSON() {
                //** Example JSON structure (To Add: Initial Sensor Base Circle Radius - Initial Sensor Height - Description - Orbits to Go) **//
                const satellitesData = [
                    {
                        id: "sat-1",
                        name: "sat-1",
                        color: "#00ffff",
                        perigeeAltitude: 500,
                        eccentricity: 0.1,
                        inclination: 45,
                        longitudeOfAscendingNode: 0,
                        argumentOfPeriapsis: 0,
                        speedMultiplier: 20,
                        model: "./Assets/Messenger-Sat.glb" //** Optional, Apps Constructor's this.satelliteModelPath default if not provided **//
                    },
                    {
                        id: "sat-2",
                        name: "sat-2",
                        color: "#ff00ff",
                        perigeeAltitude: 800,
                        eccentricity: 0.7,
                        inclination: 60,
                        longitudeOfAscendingNode: 120,
                        argumentOfPeriapsis: 45,
                        speedMultiplier: 20,
                        model:"./Assets/Main-Sat.glb"
                    },
                    {
                        id: "sat-3",
                        name: "sat-3",
                        color: "#ffff00",
                        perigeeAltitude: 1200,
                        eccentricity: 0.15,
                        inclination: 30,
                        longitudeOfAscendingNode: 240,
                        argumentOfPeriapsis: 90,
                        speedMultiplier: 20
                    }
                ];
                
                //** Display total count in loading indicator **//
                this.progressEl.textContent = `Loading 0/${satellitesData.length} satellites`;
                
                //** Process each satellite in the data array **//
                satellitesData.forEach((data, index) => {
                    this.createSatellite(data, index, satellitesData.length);
                });
            }
            
            /**
             * Create a satellite based on JSON data
             * @method createSatellite
             * @param {Object} data - Satellite data from JSON
             * @param {number} index - Index of this satellite
             * @param {number} total - Total number of satellites
             */
            createSatellite(data, index, total) {
                //** Satellite object **//
                const satellite = {
                    id: data.id,
                    name: data.name,
                     //** Group Container for all satellite components **//
                    group: new THREE.Group(),
                    orbitParams: {
                        perigeeAltitude: data.perigeeAltitude,
                        eccentricity: data.eccentricity,
                        inclination: data.inclination,
                        longitudeOfAscendingNode: data.longitudeOfAscendingNode,
                        argumentOfPeriapsis: data.argumentOfPeriapsis,
                        speedMultiplier: data.speedMultiplier
                    },
                    animationParams: {
                        currentTime: 0,
                        periodSeconds: 0,
                        orbitPoints: []
                    },
                    color: parseInt(data.color.replace('#', '0x'))
                };

                //** Add satellite group to scene **//
                this.scene.add(satellite.group);

                //** Add placeholder until model loads **//
                const satellitePlaceholder = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.2, 0.2),
                    new THREE.MeshStandardMaterial({ 
                        color: satellite.color,
                        emissive: satellite.color,
                        emissiveIntensity: 0.5
                    })
                );
                satellitePlaceholder.lookAt(0, 0, 0);
                satellite.group.add(satellitePlaceholder);

                //** 1- Satellite highlight dot **//
                const highlightGeometry = new THREE.SphereGeometry(0.03, 16, 16);
                const highlightMaterial = new THREE.MeshBasicMaterial({ 
                    color: satellite.color,
                    transparent: true,
                    opacity: 0.8
                });
                satellite.highlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
                satellite.group.add(satellite.highlight);

                //** 2- Sensor cone pointing to Earth **//
                //* Height is 1 by default, should be passed with the satellite data along with the base radius *//
                const coneGeometry = new THREE.ConeGeometry(0.3, 1, 64); 

                const coneMaterial = new THREE.MeshBasicMaterial({ 
                    color: satellite.color,
                    transparent: true,
                    opacity: 0.2
                });

                satellite.sensorCone = new THREE.Mesh(coneGeometry, coneMaterial);
                
                //* Position the cone slightly below the satellite *//
                satellite.sensorCone.position.set(0, -0.05, 0);
                satellite.sensorCone.lookAt(0, 0, 0);

               
                satellite.group.add(satellite.sensorCone);

                //** 3- Satellite label **//
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 300;
                canvas.height = 128;

                context.font = 'Bold 32px Arial';
                context.fillStyle = data.color;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(data.name, 128, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const labelMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });

                satellite.label = new THREE.Sprite(labelMaterial);
                satellite.label.scale.set(2, 0.8, 1);
                satellite.labelBaseScale = {x: 2, y: 0.8, z: 1};
                satellite.group.add(satellite.label);

                //** Calculate orbit points **//
                this.calculateSatelliteOrbit(satellite);

                //** Create orbit path visualization **//
                this.createSatelliteOrbitPath(satellite);

                //** 3D model loading **//
                const modelPath = data.model || this.satelliteModelPath;
                this.loadSatelliteModel(
                    modelPath,
                    satellitePlaceholder,
                    satellite.group,
                    index,
                    total
                );

                //** Satellite -> satellites array **//
                this.satellites.push(satellite);

                //** Initialize the cone's height and orientation **//
                this.updateSensorCone(satellite);
            }

            /**
            * Load the satellite 3D model
            * @method loadSatelliteModel
            * @param {string} modelPath - Path to the GLB model
            * @param {THREE.Object3D} placeholder - Placeholder to replace
            * @param {THREE.Group} group - Group to add model to
            * @param {number} index - Index of current satellite
            * @param {number} total - Total number of satellites
            */
            loadSatelliteModel(modelPath, placeholder, group, index, total) {
                this.gltfLoader.load(
                    modelPath,
                    (gltf) => {
                        group.remove(placeholder);
                        
                        //** Add the loaded model and scale it**//
                        const satelliteModel = gltf.scene;
                        satelliteModel.scale.set(0.005, 0.005, 0.005);
                        satelliteModel.castShadow = true;
                        
                        satelliteModel.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                if (child.material) {
                                    child.material.emissive = new THREE.Color(0x555555);
                                }
                            }
                        });
                        
                        group.add(satelliteModel);
                        
                        //** Update progress **//
                        this.progressEl.textContent = `Loading ${index + 1}/${total} satellites`;
                        
                        //** Hide loading indicator when all satellites are loaded **//
                        if (index === total - 1) {
                            this.loadingEl.style.display = 'none';
                        }
                    },
                    (xhr) => {
                        //** Update progress for this satellite **//
                        const percentComplete = Math.round((xhr.loaded / xhr.total) * 100);
                        this.progressEl.textContent = `Loading ${index + 1}/${total} satellites (${percentComplete}%)`;
                    },
                    (error) => {
                        console.error('Error loading satellite model:', error);
                        placeholder.material.emissiveIntensity = 1.0;
                        this.progressEl.textContent = `Loading ${index + 1}/${total} satellites (Error)`;
                        
                        //** Hide loading indicator if all satellites attempted to load **//
                        if (index === total - 1) {
                            setTimeout(() => {
                                this.loadingEl.style.display = 'none';
                            }, 3000);
                        }
                    }
                );
            }
            
            /**
            * Calculate satellite orbit
            * @method calculateSatelliteOrbit
            * @param {Object} satellite - Satellite object
            */
            calculateSatelliteOrbit(satellite) {
                const result = this.calculateSatelliteOrbitalTrajectory(
                    satellite.orbitParams.perigeeAltitude,
                    satellite.orbitParams.eccentricity,
                    satellite.orbitParams.inclination,
                    satellite.orbitParams.longitudeOfAscendingNode,
                    satellite.orbitParams.argumentOfPeriapsis
                );
                
                satellite.animationParams.periodSeconds = result.periodSeconds;
                satellite.animationParams.orbitPoints = result.points3D;
            }
            
            /**
            * Create orbit path visualization for a satellite
            * @method createSatelliteOrbitPath
            * @param {Object} satellite - Satellite object
            */
            createSatelliteOrbitPath(satellite) {
                //** Create the orbit path geometry from calculated points **//
                const geometry = new THREE.BufferGeometry().setFromPoints(satellite.animationParams.orbitPoints);
                
                //** Create a line material **//
                const material = new THREE.LineBasicMaterial({
                    color: satellite.color,
                    transparent: true,
                    opacity: 0.8
                });
                
                //** Create the line **//
                const orbitPath = new THREE.Line(geometry, material);
                this.scene.add(orbitPath);
                
                //** Store reference to the orbit path **//
                satellite.orbitPath = orbitPath;
                this.orbitPaths.push(orbitPath);
            }
            
            /**
            * Calculate satellite orbital trajectory using Keplerian orbital elements
            * @method calculateSatelliteOrbitalTrajectory
            * @param {number} perigeeAltitude - Altitude at perigee in km
            * @param {number} eccentricity - Orbit eccentricity (0-1)
            * @param {number} inclination - Orbit inclination in degrees
            * @param {number} longitudeOfAscendingNode - Longitude of ascending node in degrees
            * @param {number} argumentOfPeriapsis - Argument of periapsis in degrees
            * @returns {Object} Object containing orbital points and period
            */
            calculateSatelliteOrbitalTrajectory(perigeeAltitude, eccentricity, inclination, longitudeOfAscendingNode, argumentOfPeriapsis) {
                const earthRadius = 6371;                                           //** Unit: km **//
                const perigeeRadius = earthRadius + perigeeAltitude;
                const semiMajorAxis = perigeeRadius / (1 - eccentricity);
                const semiMajorAxisMeters = semiMajorAxis * 1000;
                const GM = 3.986004418e14;                                          //** Unit: m³/s² **//
                const periodSeconds = 2 * Math.PI * Math.sqrt(Math.pow(semiMajorAxisMeters, 3) / GM);
                
                //** Sampling factor for numerical orbit calculation (Standarized in 500) **//
                const numSamples = 500;
                const timeStepSeconds = periodSeconds / numSamples;
                
                const cartesianValues = [];
                const points3D = [];
                
                for (let i = 0; i <= numSamples; i++) {
                    const timeSeconds = i * timeStepSeconds;
                    const meanAnomaly = (i / numSamples) * 2 * Math.PI;
                    
                    //** Kepler's Equation for Eccentric Anomaly, numerically approximated **//
                    let eccentricAnomaly = meanAnomaly;
                    let delta = 1e-6;
                    for (let j = 0; j < 50; j++) {
                        let newEccentricAnomaly = meanAnomaly + eccentricity * Math.sin(eccentricAnomaly);
                        if (Math.abs(newEccentricAnomaly - eccentricAnomaly) < delta) {
                            break;
                        }
                        eccentricAnomaly = newEccentricAnomaly;
                    }
                    
                    const trueAnomaly = 2 * Math.atan2(
                        Math.sqrt(1 + eccentricity) * Math.sin(eccentricAnomaly / 2),
                        Math.sqrt(1 - eccentricity) * Math.cos(eccentricAnomaly / 2)
                    );
                    const radius = semiMajorAxisMeters * (1 - eccentricity * Math.cos(eccentricAnomaly));
                    
                    //** 1- Cartesian Position in orbital plane **//
                    const x = radius * Math.cos(trueAnomaly);
                    const y = radius * Math.sin(trueAnomaly);
                    
                    //** Convert degrees to radians **//
                    const inclinationRad = inclination * Math.PI / 180;
                    const lonAscNodeRad = longitudeOfAscendingNode * Math.PI / 180;
                    const argPeriapsisRad = argumentOfPeriapsis * Math.PI / 180;
                    
                    //** 1- Rotate by argument of periapsis **//
                    let xTemp = x * Math.cos(argPeriapsisRad) - y * Math.sin(argPeriapsisRad);
                    let yTemp = x * Math.sin(argPeriapsisRad) + y * Math.cos(argPeriapsisRad);
                    
                    //** 2- Rotate by inclination **//
                    let xNew = xTemp;
                    let yNew = yTemp * Math.cos(inclinationRad);
                    let z = yTemp * Math.sin(inclinationRad);
                    
                    //** 3- Rotate by longitude of ascending node **//
                    let xFinal = xNew * Math.cos(lonAscNodeRad) - yNew * Math.sin(lonAscNodeRad);
                    let yFinal = xNew * Math.sin(lonAscNodeRad) + yNew * Math.cos(lonAscNodeRad);
                    
                    //** Convert from meters to scene units and store **//
                    const xScene = xFinal * this.scaleFactor / 1000;
                    const yScene = yFinal * this.scaleFactor / 1000;
                    const zScene = z * this.scaleFactor / 1000;
                    
                    cartesianValues.push(timeSeconds, xScene, yScene, zScene);
                    points3D.push(new THREE.Vector3(xScene, yScene, zScene));
                }
                
                return { 
                    cartesianValues: cartesianValues,
                    points3D: points3D,
                    periodSeconds: periodSeconds
                };
            }
            
            /**
            * Update satellite position and orientation
            * @method updateSatellites
            */
            updateSatellites() {
                //** Update each satellite **//
                this.satellites.forEach(satellite => {
                    //** Animation time **//
                    satellite.animationParams.currentTime += 0.016 * satellite.orbitParams.speedMultiplier;
                    
                    //** Update position **//
                    this.updateSatellitePosition(satellite);
                    
                    //** Update orientation to always face Earth **//
                    this.updateSatelliteOrientation(satellite);
                    
                    //** Update cone to always point to Earth **//
                    this.updateSensorCone(satellite);
                    
                    //** Update label scale based on distance to camera **//
                    this.updateSatelliteLabel(satellite);
                });
            }
            
            /**
            * Update satellite position
            * @method updateSatellitePosition
            * @param {Object} satellite - Satellite object
            */
            updateSatellitePosition(satellite) {
                if (!satellite.animationParams.orbitPoints.length) return;
                
                const points = satellite.animationParams.orbitPoints;
                const totalPoints = points.length;
                
                //** Calculate position index based on time **//
                const normalizedTime = (satellite.animationParams.currentTime % satellite.animationParams.periodSeconds) / satellite.animationParams.periodSeconds;
                const index = Math.floor(normalizedTime * (totalPoints - 1));
                const nextIndex = (index + 1) % totalPoints;
                
                //** Interpolate between points for smooth movement **//
                const fraction = (normalizedTime * (totalPoints - 1)) - index;
                const position = new THREE.Vector3();
                position.lerpVectors(points[index], points[nextIndex], fraction);
                
                //** Update satellite position **//
                satellite.group.position.copy(position);
            }
            
            /**
             * Update satellite orientation to always face Earth
             * @method updateSatelliteOrientation
             * @param {Object} satellite - Satellite object
             */
            updateSatelliteOrientation(satellite) {
                if (!satellite.group || !satellite.group.position) return;
                
                //** Look at Earth **//
                satellite.group.lookAt(0, 0, 0);
            }
            
            /**
             * Update sensor cone to always point to Earth
             * @method updateSensorCone
             * @param {Object} satellite - Satellite object
             */
            updateSensorCone(satellite) {
                if (!satellite.sensorCone) return;
                //** Update cone to always be underneath the satellite **//
                const satellitePosition = satellite.group.position;
                const altitude = satellitePosition.length() - 4; // Altitude in scene units
                
                console.log(altitude)
                satellite.sensorCone.scale.set(1,altitude<1 ?1:altitude,1);
                satellite.sensorCone.position.set(0, 0, altitude<1 ? 0.5 : altitude*0.5);
            }

            /**
            * Update satellite label scale based on distance to camera
            * @method updateSatelliteLabel
            * @param {Object} satellite - Satellite object
            */
            updateSatelliteLabel(satellite) {
                if (!satellite.label || !satellite.labelBaseScale) return;
                
                //** Get distance from camera to calculate scale factor **//
                const distanceToCamera = this.camera.position.distanceTo(satellite.group.position);
                
                //** Scale factor - adjust the division factor to tune the scaling sensitivity **//
                const scaleFactor = distanceToCamera / 15;
                
                //** Apply dynamic scaling based on distance **//
                satellite.label.scale.set(
                    satellite.labelBaseScale.x * scaleFactor,
                    satellite.labelBaseScale.y * scaleFactor,
                    satellite.labelBaseScale.z
                );
                
                //** Position label above satellite **//
                satellite.label.position.set(0.5, 0.2, 0);
            }
            
            /**
            * Add a JSON file upload option to the UI
            * @method setupUI
            */
            setupUI() {
                const controls = document.getElementById('controls');
                
                //** Create a file input for JSON uploads **//
                const fileInputDiv = document.createElement('div');
                fileInputDiv.innerHTML = `
                    <label for="satellitesJson">Load Satellites (JSON):</label>
                    <input type="file" id="satellitesJson" accept=".json">
                `;
                
                //** Create a reset button to clear satellites **//
                const resetButton = document.createElement('button');
                resetButton.id = 'resetSatellites';
                resetButton.textContent = 'Reset Satellites';
                
                //** Add elements to controls **//
                controls.appendChild(fileInputDiv);
                controls.appendChild(resetButton);
                
                //** Add event listener for file upload **//
                document.getElementById('satellitesJson').addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const data = JSON.parse(e.target.result);
                                this.resetSatellites();
                                this.loadSatellitesFromJSONData(data);
                            } catch (error) {
                                console.error('Error parsing JSON:', error);
                                alert('Invalid JSON file');
                            }
                        };
                        reader.readAsText(file);
                    }
                });
                
                //** Add event listener for reset button **//
                document.getElementById('resetSatellites').addEventListener('click', () => {
                    this.resetSatellites();
                });
            }
            
            /**
            * Load satellites from provided JSON data
            * @method loadSatellitesFromJSONData
            * @param {Array} data - Array of satellite data objects
            */
            loadSatellitesFromJSONData(data) {
                if (!Array.isArray(data)) {
                    console.error('Invalid data format: Expected an array');
                    return;
                }
                
                //** Show loading indicator **//
                this.loadingEl.style.display = 'block';
                this.progressEl.textContent = `Loading 0/${data.length} satellites`;
                
                //** Process each satellite in the data array **//
                data.forEach((satelliteData, index) => {
                    this.createSatellite(satelliteData, index, data.length);
                });
            }
            
            /**
            * Reset satellites, clearing all existing ones
            * @method resetSatellites
            */
            resetSatellites() {
                //** Remove all satellite groups from scene **//
                this.satellites.forEach(satellite => {
                    this.scene.remove(satellite.group);
                    if (satellite.orbitPath) {
                        this.scene.remove(satellite.orbitPath);
                    }
                });
                
                //** Clear arrays **//
                this.satellites = [];
                this.orbitPaths = [];
            }
            
            /**
            * Animation loop
            * @method animate
            */
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                //** Update satellites **//
                this.updateSatellites();
                
                if (this.clouds) {
                    this.clouds.rotation.y += 0.00002;
                }
                
                //** Update controls **//
                this.controls.update();
                
                //** Render **//
                this.renderer.render(this.scene, this.camera);
            }
            
            /**
            * Add event listeners for window resize
            * @method addEventListeners
            */
            addEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
        }

        /**
        * Initialize the application when the document is loaded
        */
        document.addEventListener('DOMContentLoaded', () => {
            const app = new EarthSatelliteApp();
        });
    </script>
</body>
</html>