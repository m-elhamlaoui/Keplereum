<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Dynamic Satellite Orbit Change</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.105.0/Cesium.js"></script>
  <script src="CONFIG.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.105.0/Widgets/widgets.min.css" rel="stylesheet">
  <link href="main.css" rel="stylesheet">
</head>
<body>
  <div id="cesiumContainer"></div>
  <div class="control-panel">
    <h3>Satellite Orbit Control</h3>
    <button onclick="changeOrbit(8600)">Change Orbit to 1000km</button>
  </div>

  <script>
    // Cesium Viewer Initialization //
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI2YTkwNzk4NC04NjkzLTQ3MjAtOTRiNC1jMzdmMGJjNmJmZjAiLCJpZCI6Mjc4NzMxLCJpYXQiOjE3NDA0MTAyNTB9.oMFuN-pmxQfzZz3_p5SdB_JLhd-M5Bl-Iw5Lh25BJ5I';
    const viewer = new Cesium.Viewer('cesiumContainer', {
        animation: true,
        timeline: false
    });

    viewer.cesiumWidget.creditContainer.style.display = "none";
    viewer.clock.shouldAnimate = true; 


    /** Main Satellite Orbital Testing **/
    //////////////////////////////////////

    let currentAltitude = 1000; let dataSource;
    
    /**
     * Calculates the satellite orbital trajectory using Kepler's formulas.
     * @param {number} perigeeAltitude - The altitude at the perigee (closest point to Earth) in kilometers.
     * @param {number} eccentricity - The eccentricity of the orbit.
     * @param {number} inclination - The inclination of the orbit in degrees.
     * @param {number} longitudeOfAscendingNode - The longitude of the ascending node in degrees.
     * @param {number} argumentOfPeriapsis - The argument of periapsis in degrees.
     * @returns {Array} An array of cartesian coordinates representing the satellite's trajectory.
     */
    function calculateSatelliteOrbitalTrajectory(perigeeAltitude, eccentricity, inclination, longitudeOfAscendingNode, argumentOfPeriapsis) {
      const earthRadius = 6371;
      const perigeeRadius = earthRadius + perigeeAltitude;
      const semiMajorAxis = perigeeRadius / (1 - eccentricity);
      const semiMajorAxisMeters = semiMajorAxis * 1000;
      const GM = 3.986004418e14;
      const periodSeconds = 2 * Math.PI * Math.sqrt(Math.pow(semiMajorAxisMeters, 3) / GM);
      
      const numSamples = 240;
      const timeStepSeconds = periodSeconds / numSamples;
      
      const cartesianValues = [];
      
      for (let i = 0; i <= numSamples; i++) {
        const timeSeconds = i * timeStepSeconds;
        const meanAnomaly = (i / numSamples) * 2 * Math.PI;
        
        // Kepler's Equation for Eccentric Anomaly //
        let eccentricAnomaly = meanAnomaly;
        let delta = 1e-6;
        for (let j = 0; j < 50; j++) {
          let newEccentricAnomaly = meanAnomaly + eccentricity * Math.sin(eccentricAnomaly);
          if (Math.abs(newEccentricAnomaly - eccentricAnomaly) < delta) {
            break;
          }
          eccentricAnomaly = newEccentricAnomaly;
        }
        

        const trueAnomaly = 2 * Math.atan2(
          Math.sqrt(1 + eccentricity) * Math.sin(eccentricAnomaly / 2),
          Math.sqrt(1 - eccentricity) * Math.cos(eccentricAnomaly / 2)
        );
        const radius = semiMajorAxisMeters * (1 - eccentricity * Math.cos(eccentricAnomaly));
        

        // Cartesian Position in orbital plane // 
        const x = radius * Math.cos(trueAnomaly);
        const y = radius * Math.sin(trueAnomaly);
        
        // Inclination -> Radians //
        const inclinationRad = Cesium.Math.toRadians(inclination);
        const lonAscNodeRad = Cesium.Math.toRadians(longitudeOfAscendingNode);
        const argPeriapsisRad = Cesium.Math.toRadians(argumentOfPeriapsis);
        
        // 1- Rotate by argument of periapsis //
        let xTemp = x * Math.cos(argPeriapsisRad) - y * Math.sin(argPeriapsisRad);
        let yTemp = x * Math.sin(argPeriapsisRad) + y * Math.cos(argPeriapsisRad);
        
        // 2- Rotate by inclination //
        let xNew = xTemp;
        let yNew = yTemp * Math.cos(inclinationRad);
        let z = yTemp * Math.sin(inclinationRad);
        
        // 3- Rotate by longitude of ascending node //
        let xFinal = xNew * Math.cos(lonAscNodeRad) - yNew * Math.sin(lonAscNodeRad);
        let yFinal = xNew * Math.sin(lonAscNodeRad) + yNew * Math.cos(lonAscNodeRad);
        
        cartesianValues.push(timeSeconds, xFinal, yFinal, z);
      }

      return cartesianValues;
    }

    /**
     * Generates a CZML document for the satellite.
     * @returns {Array} The CZML document as an array.
     */
    function generateSatelliteCzml() {
      const now = Cesium.JulianDate.now();
      const start = now;
      const stop = Cesium.JulianDate.addHours(now, 4000, new Cesium.JulianDate());
      
      // CZML JSON Array //
      const czml = [
        {
          id: "document",
          name: "CZML Satellite Orbit",
          version: "1.0",
          clock: {
            interval: `${Cesium.JulianDate.toIso8601(start)}/${Cesium.JulianDate.toIso8601(stop)}`,
            currentTime: Cesium.JulianDate.toIso8601(start),
            multiplier: 1
          }
        },
        {
          id: "Satellite",
          name: `ISDA-K89`,
          availability: `${Cesium.JulianDate.toIso8601(start)}/${Cesium.JulianDate.toIso8601(stop)}`,
          description: `Initial testing satellite (${currentAltitude}km altitude orbit)`,
          model: {
            gltf: "./Assets/Main-Sat.glb",
            minimumPixelSize: 128,
            maximumScale: 200000,
          },
          path: {
            show: true,
            width: 2,
            material: {
              solidColor: {
                color: {
                  rgba: [255, 255, 0, 255]
                }
              }
            },
            resolution: 120
          },
          position: {
            interpolationAlgorithm: "LAGRANGE",
            interpolationDegree: 5,
            referenceFrame: "FIXED",
            epoch: Cesium.JulianDate.toIso8601(start),
            cartesian: []
          }
        }
      ];
      
      czml[1].position.cartesian = calculateSatelliteOrbitalTrajectory(currentAltitude, 0.3, 51, 0, 0);
      return czml;
    }

    /**
     * Loads the satellite data source into the Cesium viewer.
     */
     function loadSatellite() {
      viewer.dataSources.remove(dataSource, true);
      dataSource = new Cesium.CzmlDataSource();
      dataSource.load(czml).then(function() {
        viewer.dataSources.add(dataSource);
      });
    }

    /**
     * Converts an array of positions to Cartesian3 coordinates (For Polygon Generation)
     * @param {Array} positions - The array of positions.
     * @returns {Array} An array of Cartesian3 coordinates.
     */
     function convertToCartesian3(positions) {
      const cartesian3Positions = [];
      for (let i = 1; i < positions.length; i += 4) {
        cartesian3Positions.push(new Cesium.Cartesian3(positions[i], positions[i+1], positions[i+2]));
      }
      return cartesian3Positions;
    }

    /**
     * Interpolates between two sets of Cartesian coordinates.
     * @param {Array} initial - The initial set of Cartesian coordinates.
     * @param {Array} final - The final set of Cartesian coordinates.
     * @param {number} t - The interpolation factor (0 to 1).
     * @returns {Array} The interpolated Cartesian coordinates.
     */
     function interpolateCartesian(initial, final, t) {
      const interpolated = [];
      for (let i = 0; i < initial.length; i+=4) {
        const temp = (1 - t) * initial[i] + t * final[i];
        const x = (1 - t) * initial[i+1] + t * final[i+1];
        const y = (1 - t) * initial[i+2] + t * final[i+2];
        const z = (1 - t) * initial[i+3] + t * final[i+3];
        interpolated.push(temp, x, y, z);
      }
      return interpolated;
    }

    /**
     * Changes the orbit altitude of the satellite.
     * @param {number} newAltitude - The new altitude for the satellite's orbit.
     */
     function changeOrbit(newAltitude) {
      // Initial and final orbits //
      const initialOrbit = czml[1].position.cartesian;
      const finalOrbit = calculateSatelliteOrbitalTrajectory(newAltitude, 0.6, 51, 0, 0);

      // Final orbital rendering (red polyline) //
      viewer.entities.add({
        polyline: {
          positions: convertToCartesian3(finalOrbit),
          width: 1,
          material: Cesium.Color.RED
        }
      });

      let t = 0;
      const duration = 10;
      const step = 0.01;

      function interpolate() {
        if (t < 1) {
          t += step / duration;
          const interpolatedOrbit = interpolateCartesian(initialOrbit, finalOrbit, t);
          czml[1].position.cartesian = interpolatedOrbit;
          loadSatellite();
          setTimeout(interpolate, step * 2000);
        }
      }
      interpolate();
    }

    /*************************************************************************************************************/
    /*************************************************************************************************************/

    // CZML Generation //
    const czml = generateSatelliteCzml();
    
    // CZML Document Loading //
    dataSource = new Cesium.CzmlDataSource();
    
    // Satellite Initialization //
    loadSatellite();

  </script>
</body>
</html>