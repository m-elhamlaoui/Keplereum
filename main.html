<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Dynamic Satellite Orbit Change</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.105.0/Cesium.js"></script>
  <script src="CONFIG.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/cesium/1.105.0/Widgets/widgets.min.css" rel="stylesheet">
  <link href="main.css" rel="stylesheet">
</head>
<body>
  <div id="cesiumContainer"></div>
  <div class="control-panel">
    <h3>Satellite Orbit Control</h3>
    <button onclick="changeOrbit(8600)">Change Orbit to 1000km</button>
  </div>

  <script>
    // Cesium Viewer Initialization //
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI2YTkwNzk4NC04NjkzLTQ3MjAtOTRiNC1jMzdmMGJjNmJmZjAiLCJpZCI6Mjc4NzMxLCJpYXQiOjE3NDA0MTAyNTB9.oMFuN-pmxQfzZz3_p5SdB_JLhd-M5Bl-Iw5Lh25BJ5I';
    const viewer = new Cesium.Viewer('cesiumContainer', {
        animation: true,
        timeline: false
    });

    viewer.cesiumWidget.creditContainer.style.display = "none";
    viewer.clock.shouldAnimate = true; 


    /** Main Satellite Orbital Testing **/
    //////////////////////////////////////

    let currentAltitude = 1000; let dataSource;
    
    /**
     * Calculates the satellite orbital trajectory using Kepler's formulas.
     * @param {number} perigeeAltitude - The altitude at the perigee (closest point to Earth) in kilometers.
     * @param {number} eccentricity - The eccentricity of the orbit.
     * @param {number} inclination - The inclination of the orbit in degrees.
     * @param {number} longitudeOfAscendingNode - The longitude of the ascending node in degrees.
     * @param {number} argumentOfPeriapsis - The argument of periapsis in degrees.
     * @returns {Array} An array of cartesian coordinates representing the satellite's trajectory.
     */
    function calculateSatelliteOrbitalTrajectory(perigeeAltitude, eccentricity, inclination, longitudeOfAscendingNode, argumentOfPeriapsis) {
      const earthRadius = 6371;
      const perigeeRadius = earthRadius + perigeeAltitude;
      const semiMajorAxis = perigeeRadius / (1 - eccentricity);
      const semiMajorAxisMeters = semiMajorAxis * 1000;
      const GM = 3.986004418e14;                                                                /* (m^3/s^2) */
      const periodSeconds = 2 * Math.PI * Math.sqrt(Math.pow(semiMajorAxisMeters, 3) / GM);
      
      const numSamples = 120;
      const timeStepSeconds = periodSeconds / numSamples;
      
      const cartesianValues = [];
      
      for (let i = 0; i <= numSamples; i++) {
        const timeSeconds = i * timeStepSeconds;
        const meanAnomaly = (i / numSamples) * 2 * Math.PI;
        
        // Kepler's Equation for Eccentric Anomaly //
        let eccentricAnomaly = meanAnomaly;
        let delta = 1e-6;
        for (let j = 0; j < 50; j++) {
          let newEccentricAnomaly = meanAnomaly + eccentricity * Math.sin(eccentricAnomaly);
          if (Math.abs(newEccentricAnomaly - eccentricAnomaly) < delta) {
            break;
          }
          eccentricAnomaly = newEccentricAnomaly;
        }
        
        // True Anomaly //
        const trueAnomaly = 2 * Math.atan2(
          Math.sqrt(1 + eccentricity) * Math.sin(eccentricAnomaly / 2),
          Math.sqrt(1 - eccentricity) * Math.cos(eccentricAnomaly / 2)
        );
        
        // Radius //
        const radius = semiMajorAxisMeters * (1 - eccentricity * Math.cos(eccentricAnomaly));
        
        // Cartesian Position in orbital plane // 
        const x = radius * Math.cos(trueAnomaly);
        const y = radius * Math.sin(trueAnomaly);
        
        // Inclination -> Radians //
        const inclinationRad = Cesium.Math.toRadians(inclination);
        const lonAscNodeRad = Cesium.Math.toRadians(longitudeOfAscendingNode);
        const argPeriapsisRad = Cesium.Math.toRadians(argumentOfPeriapsis);
        
        // 1- Rotate by argument of periapsis //
        let xTemp = x * Math.cos(argPeriapsisRad) - y * Math.sin(argPeriapsisRad);
        let yTemp = x * Math.sin(argPeriapsisRad) + y * Math.cos(argPeriapsisRad);
        
        // 2- Rotate by inclination //
        let xNew = xTemp;
        let yNew = yTemp * Math.cos(inclinationRad);
        let z = yTemp * Math.sin(inclinationRad);
        
        // 3- Rotate by longitude of ascending node //
        let xFinal = xNew * Math.cos(lonAscNodeRad) - yNew * Math.sin(lonAscNodeRad);
        let yFinal = xNew * Math.sin(lonAscNodeRad) + yNew * Math.cos(lonAscNodeRad);
        
        cartesianValues.push(timeSeconds, xFinal, yFinal, z);
      }
      
      return cartesianValues;
    }


    function generateSatelliteCzml() {
      const now = Cesium.JulianDate.now();
      // console.log("now", now);
      const start = now;
      const stop = Cesium.JulianDate.addHours(now, 4000, new Cesium.JulianDate());
      
      // Create the CZML document
      const czml = [
        {
          id: "document",
          name: "CZML Satellite Orbit",
          version: "1.0",
          clock: {
            interval: `${Cesium.JulianDate.toIso8601(start)}/${Cesium.JulianDate.toIso8601(stop)}`,
            currentTime: Cesium.JulianDate.toIso8601(start),
            multiplier: 1
          }
        },
        {
          id: "Satellite",
          name: `ISDA-K89`,
          availability: `${Cesium.JulianDate.toIso8601(start)}/${Cesium.JulianDate.toIso8601(stop)}`,
          description: `Initial testing satellite (${currentAltitude}km altitude orbit)`,
            billboard:{
                eyeOffset:{
                    "cartesian":[
                    0,0,0
                    ]
                },
                horizontalOrigin:"CENTER",
                image:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADJSURBVDhPnZHRDcMgEEMZjVEYpaNklIzSEfLfD4qNnXAJSFWfhO7w2Zc0Tf9QG2rXrEzSUeZLOGm47WoH95x3Hl3jEgilvDgsOQUTqsNl68ezEwn1vae6lceSEEYvvWNT/Rxc4CXQNGadho1NXoJ+9iaqc2xi2xbt23PJCDIB6TQjOC6Bho/sDy3fBQT8PrVhibU7yBFcEPaRxOoeTwbwByCOYf9VGp1BYI1BA+EeHhmfzKbBoJEQwn1yzUZtyspIQUha85MpkNIXB7GizqDEECsAAAAASUVORK5CYII=",
                pixelOffset:{
                    cartesian2:[
                    0,0
                    ]
                },
                scale:2,
                show:true,
                verticalOrigi:"CENTER"
            },
          path: {
            show: true,
            width: 2,
            material: {
              solidColor: {
                color: {
                  rgba: [255, 255, 0, 255]
                }
              }
            },
            resolution: 120
          },
          position: {
            interpolationAlgorithm: "LAGRANGE",
            interpolationDegree: 5,
            referenceFrame: "FIXED",
            epoch: Cesium.JulianDate.toIso8601(start),
            cartesian: []
          }
        }
      ];
      
      czml[1].position.cartesian = calculateSatelliteOrbitalTrajectory(currentAltitude, 0.8, 51, 0, 0);
      return czml;
    }

    function loadSatellite() {
      dataSource.load(czml).then(function() {
        // Add to viewer
        viewer.dataSources.add(dataSource);
      });
    }

    // Change the orbit altitude
    function changeOrbit(newAltitude) {
      // Update current altitude
      currentAltitude = newAltitude;
      
      czml[1].position.cartesian = calculateSatelliteOrbitalTrajectory(currentAltitude, 0.5, 51, 0, 0);
      
      // Load new satellite orbit
      loadSatellite();
    }

    // Generate CZML for initial altitude
    const czml = generateSatelliteCzml();
    
    // Load the CZML document
    dataSource = new Cesium.CzmlDataSource();
    
    // Load initial satellite
    loadSatellite();
  </script>
</body>
</html>